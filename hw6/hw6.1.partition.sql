create table kabenyk_st.error_log(
    id_log number generated by default as identity
    (start with 1 maxvalue 9999999999999999999999999999 minvalue 1 nocycle nocache noorder)
        primary key,
    sh_user varchar2(50) default user,
    sh_dt date default sysdate,
    object_name varchar2(200),
    log_type varchar2(1000),
    params varchar2(4000)
)
partition by range (sh_dt) (
    partition part_1 values less than (to_date('20.02.2022 19:42', 'dd.mm.yyyy hh24:mi')),
    partition part_max values less than (maxvalue)
);
-- проверяем, что секции создались
select * from sys.user_tab_partitions;

-- вносим данные
declare
    v_value varchar2(100) := 'string';
begin
    for i in 1..3
    loop
        kabenyk_st.fail_method(
            p_value => v_value,
            p_need_handle => true
        );
    end loop;

    commit;
end;

-- проверяем, что данные записались
select * from kabenyk_st.error_log;

-- очищаем данные
alter table kabenyk_st.error_log truncate partition part_1;

-- проверяем, что данные удалены
select * from kabenyk_st.error_log;

-- добавляем секцию на следущие три месяца
alter table kabenyk_st.error_log
split partition part_max at (to_date('20.05.2022 19:42', 'dd.mm.yyyy hh24:mi'))
into (partition part_2, partition part_max);

-- проверяем, что секция создалась
select * from sys.user_tab_partitions;

--пересборка индекса
alter index kabenyk_st.SYS_C0028230 rebuild;

-- вносим данные во вторую секцию
declare
    v_value varchar2(100) := 'string';
begin
    for i in 1..3
    loop
        kabenyk_st.fail_method(
            p_value => v_value,
            p_is_three_month_ahead => true
        );
    end loop;

    commit;
end;

-- проверяем, что данные записались
select * from kabenyk_st.error_log;

--drop table kabenyk_st.error_log purge
--alter table kabenyk_st.error_log drop partition part_2;
